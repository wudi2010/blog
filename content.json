{"meta":{"title":"吴迪的技术博客","subtitle":"天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣","description":"天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣","author":"wudi","url":"https://wudi2010.github.io/blog"},"pages":[{"title":"all categories","date":"2016-12-02T07:43:33.000Z","updated":"2016-12-02T09:48:12.000Z","comments":false,"path":"categories/index.html","permalink":"https://wudi2010.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"alltags","date":"2016-12-02T09:31:19.000Z","updated":"2016-12-02T09:45:52.000Z","comments":false,"path":"tags/index.html","permalink":"https://wudi2010.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React + Redux 基础学习笔记","slug":"react-and-redux-learning-note-basics","date":"2016-12-05T02:29:49.000Z","updated":"2016-12-06T07:28:07.000Z","comments":true,"path":"2016/12/05/react-and-redux-learning-note-basics/","link":"","permalink":"https://wudi2010.github.io/blog/blog/2016/12/05/react-and-redux-learning-note-basics/","excerpt":"","text":"零、环境搭建参考资料 英文原版文档 中文文档 首先要明确一点，虽然 redux 是由 flux 演变而来，但我们完全可以并且也应该抛开 react进行学习，这样可以避免一开始就陷入各种细节之中。 所以推荐使用 jsbin 进行调试学习，或者使用 react-create-app作为项目脚手架。 一、Redux是什么？ Redux is a predictable state container for JavaScript apps.Redux 是一个 JavaScript 状态容器，提供可预测化的状态管理。 先不要在意那些细节 总的来说，redux 使用 store 保存并管理页面中的各种状态（state） 当需要改变 state 时，使用 dispatch 调用 action creators 触发 action 接着使用纯函数（pure function）reducer 来处理这些 action，它会根据当前 state 和 action 返回（注意这里不是修改）新的 state view 层可以对于 state 进行订阅（subscribe），这样就可以得到新的 state，从而可以刷新界面（所以十分适合数据驱动的前端框架） 纯函数：简单的说就是对于同样的输入总是返回同样的输出，并且没有副作用的函数。（推荐学习了解下函数式编程） 1.1.为什么选择 redux？ 随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。 管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。 如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗？当然不是。 这里的复杂性很大程度上来自于：我们总是将两个难以厘清的概念混淆在一起：变化和异步。 我称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 试图在视图层禁止异步和直接操作 DOM 来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。 跟随 Flux、CQRS 和 Event Sourcing 的脚步，通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。这些限制条件反映在 Redux 的 三大原则中。 简单总结就是使用 Redux 我们就可以没有蛀牙（大雾） 拥有可预测（predictable）的应用状态，所以应用的行为也是可预测的 因为 reducer 是纯函数，所以方便对于状态迁移进行自动化测试 方便地记录日志，甚至实现时间旅行（time travel） 1.2. 三大原则（哲♂学）1.2.1. 单一数据源（Single source of truth）整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中 便于调试，在开发时可以将状态保存在本地 Undo/Redo 可以轻松实现，从而实现时间旅行 1.2.2. State 是只读的（State is read-only）惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，（dispatch 同步调用 reduce 函数）因此不用担心 race condition 的出现。 Action 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。 1.2.3. 使用纯函数来执行修改（Changes are made with pure functions）为了描述 action 如何改变 state tree ，你需要编写 reducer。 Reducer 只是纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始你可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分。 二、Redux 基础2.1. actionAction 就是一个普通的 JavaScript Object。 redux 唯一限制的一点是必须有一个 type 属性用来表示执行哪种操作，值最好用字符串，而不是 Symbols，因为字符串是可被序列化的。 其他属性用来传递此次操作所需传递的数据，redux 对此不作限制，但是在设计时可以参照 Flux 标准 Action。 简单总结 Flux Standard action 就是 一个 action 必须是一个 JavaScript Object，并且有一个 type 属性。 一个 action 可以有 payload/error/meta 属性。 一个 action 不能有其他属性。 2.2. reducerReducer 的工作就是接收旧的 state 和 action，返回新的 state。 (previousState, action) =&gt; newState 之所以称作 reducer 是因为它将被传递给 [Array.prototype.reduce(reducer, ?initialValue)] 方法。保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 2.3. storeStore 就是用来维持应用所有的 state 树的一个对象。 在 redux 中只有一个 store（区别于 flux 的多个 store），在 store 中保存所有的 state，可以把它当成一个封装了 state 的类。而除了对其 dispatch 一个 action 以外无法改变内部的 state。 在实际操作中我们只需要把根部的 reducer 函数传递给 createStore 就可以得到一个 store。 1234567891011import &#123; createStore &#125; from 'redux';function reducer(state, action) &#123; switch (action.type) &#123; case 'SOME_ACTION': // 一些操作 return newState; // 返回新状态 default: return state; &#125;&#125;const store = createStore(reducer); redux 中提供了这几个 api 操作 store 2.3.1. getState返回当前的整个 state 树。 2.3.2. dispatch(action)分发 action 给对应的 reducer。 该函数会调用 getState() 和传入的 action 以【同步】的方式调用 store 的 reduce 函数，然后返回新的 state。从而 state 得到了更新，并且变化监听器（change listener）会被触发。（对于异步操作则将其放到了 action creator 这个步骤） 2.3.3. subscribe(listener)为 store 添加一个变化监听器，每当 dispatch 的时候就会执行，你可以在 listener（回调函数）中使用 getState() 来得到当前的 state。 这个 api 设计的挺有意思，它会返回一个函数，而你执行这个函数后就可以取消订阅。 2.3.4. replaceReducer(nextReducer)替换 store 当前用来计算 state 的 reducer。 这是一个高级 API。只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。在实现 Redux 热加载机制的时候也可能会用到。 2.4. createStore忽略各种类型判断，实现一个最简的 createStore 可以用以下代码。参考资料 123456789101112131415161718const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); // 调用 reducer listeners.forEach(listener =&gt; listener()); // 调用所有变化监听器 &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; // 返回解除监听函数 listeners = listeners.filter(l =&gt; l !== listener); &#125;; &#125; dispatch(&#123;&#125;); // 初始化 return &#123; getState, dispatch, subscribe &#125;;&#125;; 2.5. 计数器例子 纯 JavaScript 不涉及界面（可以在右侧 console 中尝试 store.dispatch）JS Bin on jsbin.com 增加界面JS Bin on jsbin.com 三、与 React 进行结合3.1. 通过 script 标签导入 react实现同样功能的 Counter 12345678910111213141516171819202122232425262728293031323334353637383940414243// 引入 createStore 方法const &#123; createStore &#125; = Redux;// var createStore = Redux.createStore;// import &#123; createStore &#125; from 'redux';const counter = (state = 0, action) =&gt; &#123; switch (action.type) &#123; case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; &#125;&#125;;const store = createStore(counter); // 创建 store 并绑定 reducer// dump componentconst Counter = (&#123; value, onIncrement, onDecrement&#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;&#123;value&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;onDecrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt;);const render = () =&gt; &#123; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123; type: 'INCREMENT' &#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123; type: 'DECREMENT' &#125;)&#125; /&gt;, document.getElementById('container') );&#125;;store.subscribe(render); // change listener 监听状态变化，一旦变化则触发回调函数render(); 3.2. 用 Redux 和 React 实现 TodoApp在添加 react-redux 之前，为了体会下 react-redux 的作用，首先来实现一个比计数器更复杂一点儿的 TodoApp 例子~ 3.2.1. 分析与设计1. 容器组件 V.S. 展示组件组件一般分为 容器组件（Smart/Container Components）展示组件（Dumb/Presentational Components） 容器组件 展示组件 Location 最顶层，路由处理 中间和子组件 Aware of Redux 是 否 读取数据 从Redux获取state 从props获取数据 修改数据 向Redux派发actions 从props回掉函数 最佳实践一般是由容器组件负责一些数据的获取，进行 dispatch 等操作。而展示组件组件不应该关心逻辑，所有数据都通过 props 传入。 这样才能达到展示组件可以在多处复用，在具体复用时就是通过容器组件将其包装，为其提供所需的各种数据。 2. 应用设计 一个 TodoApp 包含了三个部分： 顶部的 AddTodo 输入部分 中间的 TodoList 展示部分 底部的 Footer 过滤部分 State 应该包含： filter：过滤 todos 的条件 SHOW_ALL SHOW_ACTIVE SHOW_COMPLETED todos：所有的 todo todo：包含 id、text 和 completed 然而传到应用中的 props 只需要： visibleTodos：过滤后的 todos filter：过滤条件 Action 应该有三种： ADD_TODO TOGGLE_TODO SET_VISIBILITY_FILTER3.2.2. 编码实现 1. action 部分123456789101112// 暂且使用数字作为 idlet nextTodoId = 0;/*-- action creators --*/const addTodo = (text) =&gt; ( &#123; type: 'ADD_TODO', id: nextTodoId++, text &#125;);const toggleTodo = (id) =&gt; ( &#123; type: 'TOGGLE_TODO', id &#125;);const setVisibilityFilter = (filter) =&gt; ( &#123; type: 'SET_VISIBILITY_FILTER', filter &#125;); 2. reducer 部分12345678910111213141516171819202122232425262728293031323334// 默认初始状态const initialState = &#123; filter: 'SHOW_ALL', todos: [] &#125;;function rootReducer(state = initialState, action) &#123; switch (action.type) &#123; case 'ADD_TODO': // 对象解构 const &#123; id, text &#125; = action; return &#123; ...state, todos: [ ...state.todos, &#123; id, text, completed: false &#125;, ], &#125;; case 'TOGGLE_TODO': return &#123; ...state, todos: state.todos.map(todo =&gt; &#123; if (todo.id !== action.id) return todo; return &#123; ...todo, completed: !todo.completed, &#125;; &#125;), &#125;; case 'SET_VISIBILITY_FILTER': return &#123; ...state, filter: action.filter, &#125;; default: return state; &#125;&#125; 注意!1.不要直接修改原有的 state，而是返回一个新的 state。可以使用 Object.assign() 新建一个新的 state。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对 ES7 提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。2.在 default 的情况下返回旧的 state，用来兼容遇到未知的 action 这样的错误。 拆分 reducer目前代码看着比较冗长，其实在逻辑上 todos 的处理和 filter 的处理应该分开，所以在 state 没有互相耦合时，可以将其拆分，从而让 reducer 精细地对于对应 state 的子树进行处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 处理单个 todoconst todoReducer = (state, action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return &#123; id: action.id, text: action.text, completed: false, &#125;; case 'TOGGLE_TODO': if (state.id !== action.id) return state; return &#123; ...state, completed: !state.completed, &#125;; default: return state; &#125;&#125;;// 处理 todosconst todosReducer = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, todoReducer(undefined, action), ]; case 'TOGGLE_TODO': return state.map(t =&gt; todoReducer(t, action)); default: return state; &#125;;&#125;;// 处理 filterconst filterReducer = (state = 'SHOW_ALL', action) =&gt; &#123; switch (action.type) &#123; case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; &#125;;&#125;;const rootReducer = (state = initialState, action) =&gt; (&#123; todos: todosReducer(state.todos, action), filter: filterReducer(state.filter, action),&#125;); 注意观察最后的 rootReducer 函数，返回的是一个经过各种 reducer 处理过并合并后的新 state。 然鹅，注意这里 todos: todos(state.todos, action), 传入 state.todos，返回的一定也是 todos（因为都是 state 树上的节点）。 所以 redux 提供了很实用的 combineReducers api，用于简化 reducer 的合并。 1234567import &#123; combineReducers &#125; from 'redux';const rootReducer = combineReducers(&#123; todos: todosReducer, filter: filterReducer,&#125;);// initialState 可以作为第二个参数传入const store = createStore(rootReducer, initialState); 并且如果 reducer 与 state 节点同名的话（即 todosReducer -&gt; todos）还能通过 es6 的语法更进一步地简化1234import &#123; combineReducers &#125; from 'redux';const rootReducer = combineReducers(&#123; todos, filter &#125;);// initialState 可以作为第二个参数传入const store = createStore(rootReducer, initialState); 随着应用的膨胀，我们还可以将拆分后的 reducer 放到不同的文件中, 以保持其独立性并用于专门处理不同的数据域。 3. view 部分(1). 只有根组件首先只写一个根组件 &lt;TodoApp/&gt; ，store通过props传入TodoApp,并在生命周期的componentDidMount 和 componentWillUnmount时分别订阅与取消订阅 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import React, &#123; Component &#125; from 'react';class TodoApp extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; // 渲染单个 todo _renderTodo(todo) &#123; const &#123; store &#125; = this.props; return ( &lt;li key=&#123;todo.id&#125; onClick=&#123;() =&gt; store.dispatch(toggleTodo(todo.id))&#125; style=&#123;&#123; textDecoration: todo.completed ? 'line-through' : 'none', cursor: todo.completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;todo.text&#125; &lt;/li&gt; ); &#125; // 根据当前 filter 是否匹配，返回字符串或是 a 链接 _renderFilter(renderFilter, name) &#123; const &#123; store &#125; = this.props; const &#123; filter &#125; = store.getState(); if (renderFilter === filter) return name; return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); store.dispatch(setVisibilityFilter(renderFilter)) &#125;&#125;&gt; &#123;name&#125; &lt;/a&gt; ); &#125; // 根据当前 filter 过滤需要渲染的 todos _getVisibleTodos(todos, filter) &#123; switch (filter) &#123; case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed); case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed); default: return todos; &#125; &#125; render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); let input; return ( &lt;div&gt; &#123;/* AddTodo */&#125; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; if (!input.value) return; store.dispatch(addTodo(input.value)); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &#123;/* TodoList */&#125; &lt;ul&gt; &#123;this._getVisibleTodos(todos, filter) .map(this._renderTodo.bind(this)) &#125; &lt;/ul&gt; &#123;/* Footer */&#125; &lt;p&gt; Show: &#123;' '&#125; &#123;this._renderFilter('SHOW_ALL', 'all')&#125; &#123;', '&#125; &#123;this._renderFilter('SHOW_COMPLETED', 'completed')&#125; &#123;', '&#125; &#123;this._renderFilter('SHOW_ACTIVE', 'active')&#125; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125; TodoApp 只有根组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196// 引入 createStore 方法const &#123; createStore, combineReducers &#125; = Redux;const &#123; Component &#125; = React;// 暂且使用数字作为 idlet nextTodoId = 0;/*-- action creators --*/const addTodo = (text) =&gt; ( &#123; type: 'ADD_TODO', id: nextTodoId++, text &#125;);const toggleTodo = (id) =&gt; ( &#123; type: 'TOGGLE_TODO', id &#125;);const setVisibilityFilter = (filter) =&gt; ( &#123; type: 'SET_VISIBILITY_FILTER', filter &#125;);/*-- reducers --*/// 默认初始状态const initialState = &#123; filter: 'SHOW_ALL', todos: [] &#125;;// 处理单个 todoconst todo = (state, action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return &#123; id: action.id, text: action.text, completed: false, &#125;; case 'TOGGLE_TODO': if (state.id !== action.id) return state; return &#123; ...state, completed: !state.completed, &#125;; default: return state; &#125;&#125;;// 处理 todosconst todos = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, todo(undefined, action), ]; case 'TOGGLE_TODO': return state.map(t =&gt; todo(t, action)); default: return state; &#125;&#125;;// 处理 filterconst filter = (state = 'SHOW_ALL', action) =&gt; &#123; switch (action.type) &#123; case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; &#125;&#125;;const rootReducer = combineReducers(&#123; todos, filter &#125;);/*-- view --*/class TodoApp extends Component &#123; render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); let input; return ( &lt;div&gt; &#123;/* AddTodo */&#125; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; if (!input.value) return; store.dispatch(addTodo(input.value)); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &#123;/* TodoList */&#125; &lt;ul&gt; &#123; this._getVisibleTodos(todos, filter) .map(this._renderTodo.bind(this)) &#125; &lt;/ul&gt; &#123;/* Footer */&#125; &lt;p&gt; Show: &#123;' '&#125; &#123;this._renderFilter('SHOW_ALL', 'all')&#125; &#123;', '&#125; &#123;this._renderFilter('SHOW_COMPLETED', 'completed')&#125; &#123;', '&#125; &#123;this._renderFilter('SHOW_ACTIVE', 'active')&#125; &lt;/p&gt; &lt;/div&gt; ); &#125; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; // 渲染单个 todo _renderTodo(todo) &#123; const &#123; store &#125; = this.props; return ( &lt;li key=&#123;todo.id&#125; onClick=&#123;() =&gt; store.dispatch(toggleTodo(todo.id))&#125; style=&#123;&#123; textDecoration: todo.completed ? 'line-through' : 'none', cursor: todo.completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;todo.text&#125; &lt;/li&gt; ); &#125; // 根据当前 filter 是否匹配，返回字符串或是 a 链接 _renderFilter(renderfilter, name) &#123; const &#123; store &#125; = this.props; const &#123; filter &#125; = store.getState(); if (renderfilter === filter) return name; return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); store.dispatch(setVisibilityFilter(renderfilter)) &#125;&#125;&gt; &#123;name&#125; &lt;/a&gt; ); &#125; // 根据当前 filter 过滤需要渲染的 todos _getVisibleTodos(todos, filter) &#123; switch (filter) &#123; case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed); case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed); default: return todos; &#125; &#125;&#125;/*-- ReactDOM 渲染部分 --*/ReactDOM.render( &lt;TodoApp store=&#123;createStore(rootReducer, initialState)&#125; /&gt;, document.getElementById('container'),); (2).组件拆分将所有界面内容写在TodoApp中实在是太臃肿了，接下来根据之前的分析结果将其分为以下子组件（全是展示组件） AddTodo TodoList Todo Footer FilterLink 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const AddTodo = (&#123; onAddClick &#125;) =&gt; &#123; let input; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; onAddClick(input.value); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &lt;/div&gt; );&#125;;const Todo = (&#123; text, onClick, completed &#125;) =&gt; ( &lt;li onClick=&#123;onClick&#125; style=&#123;&#123; textDecoration: completed ? 'line-through' : 'none', cursor: completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;text&#125; &lt;/li&gt;);const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; )&#125; &lt;/ul&gt;);const FilterLink = (&#123; filter, onClick, renderFilter, children &#125;) =&gt; &#123; if (renderFilter === filter) return (&lt;span&gt;&#123;children&#125;&lt;/span&gt;); return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); onClick(renderFilter); &#125;&#125;&gt; &#123;children&#125; &lt;/a&gt; );&#125;;const Footer = (&#123; filter, onFilterClick &#125;) =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink filter=&#123;filter&#125; renderFilter=\"SHOW_ALL\" onClick=&#123;onFilterClick&#125; &gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink filter=&#123;filter&#125; renderFilter=\"SHOW_COMPLETED\" onClick=&#123;onFilterClick&#125; &gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink filter=&#123;filter&#125; renderFilter=\"SHOW_ACTIVE\" onClick=&#123;onFilterClick&#125; &gt; active &lt;/FilterLink&gt; &lt;/p&gt;); 所以 TodoApp 精简后是这样~ 123456789101112131415161718192021222324252627class TodoApp extends Component &#123; // ... render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); return ( &lt;div&gt; &lt;AddTodo onAddClick=&#123;text =&gt; &#123; if (!text) return; store.dispatch(addTodo(text)); &#125;&#125; /&gt; &lt;TodoList todos=&#123;this._getVisibleTodos(todos, filter)&#125; onTodoClick=&#123;id =&gt; store.dispatch(toggleTodo(id))&#125; /&gt; &lt;Footer filter=&#123;filter&#125; onFilterClick=&#123;filter =&gt; &#123; store.dispatch(setVisibilityFilter(filter)); &#125;&#125; /&gt; &lt;/div&gt; ); &#125;&#125; (3). 增加容器组件现在我们仍然是以 TodoApp 作为容器组件，其中各个子组件都是展示组件。 但是这样做的话一旦子组件需要某个属性，就需要从根组件层层传递下来，比如 FilterLink 中的 filter 属性。 所以下面我们增加容器组件，让展示组件通过容器组件获得所需属性。 AddTodo(container) VisibleTodoList(container) TodoList Todo Footer FilterLink(container) Link 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// store.dispatch 又被放回来了，// 因为暂时我们只在 AddTodo 组件中使用 addTodo 这个 action// 以后增加了新的 form 之后可以考虑再将 store.dispatch 移出去const AddTodo = (&#123; store &#125;) =&gt; &#123; let input; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; if (!input.value) return; store.dispatch(addTodo(input.value)); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &lt;/div&gt; );&#125;;const Todo = (&#123; text, onClick, completed &#125;) =&gt; ( &lt;li onClick=&#123;onClick&#125; style=&#123;&#123; textDecoration: completed ? 'line-through' : 'none', cursor: completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;text&#125; &lt;/li&gt;);const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; )&#125; &lt;/ul&gt;);// 容器组件class VisibleTodoList extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; // 根据当前 filter 过滤需要渲染的 todos _getVisibleTodos(todos, filter) &#123; switch (filter) &#123; case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed); case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed); default: return todos; &#125; &#125; render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); return ( &lt;TodoList todos=&#123;this._getVisibleTodos(todos, filter)&#125; onTodoClick=&#123;id =&gt; &#123; store.dispatch(toggleTodo(id)) &#125;&#125; /&gt; ); &#125;&#125; // 原本的 FilterLink 改成 Link，去掉 filter 和 renderFilter 属性，改为传入 activeconst Link = (&#123; active, onClick, children &#125;) =&gt; &#123; if (active) return (&lt;span&gt;&#123;children&#125;&lt;/span&gt;); return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); onClick(); &#125;&#125;&gt; &#123;children&#125; &lt;/a&gt; );&#125;;// 容器组件class FilterLink extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; render() &#123; const &#123; store, renderFilter, children &#125; = this.props; const &#123; filter &#125; = store.getState(); return ( &lt;Link active=&#123;filter === renderFilter&#125; onClick=&#123;() =&gt; store.dispatch( setVisibilityFilter(renderFilter) )&#125; &gt; &#123;children&#125; &lt;/Link&gt; ); &#125;&#125;// 展示组件const Footer = (&#123; store &#125;) =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink store=&#123;store&#125; renderFilter=\"SHOW_ALL\" &gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink store=&#123;store&#125; renderFilter=\"SHOW_COMPLETED\" &gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink store=&#123;store&#125; renderFilter=\"SHOW_ACTIVE\" &gt; active &lt;/FilterLink&gt; &lt;/p&gt;);// 在不使用全局变量 store 的情况下，// 暂时只能通过 props 传递进来，// Don't worry~很快就不会这么麻烦了~const TodoApp = (&#123; store &#125;) =&gt; ( &lt;div&gt; &lt;AddTodo store=&#123;store&#125; /&gt; &lt;VisibleTodoList store=&#123;store&#125; /&gt; &lt;Footer store=&#123;store&#125; /&gt; &lt;/div&gt;); 通过观察重构后的代码可以发现有三点麻烦的地方 根组件需要通过 props 将 store 传给各个子组件 容器组件都要定义 componentDidMount 进行订阅和 componentWillUnmount 取消订阅 应用其实并不需要渲染所有的 todos，所以内部很麻烦地定义了 _getVisibleTodos 函数 (4). Provider让我们先来解决第一个麻烦~，利用 React 提供的 context 特性 12345678910111213class Provider extends Component &#123; // 通过该方法向 children 的 context 注入 store getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return this.props.children; &#125;&#125;// 必须要声明传入 context 的 store 的类型Provider.childContextTypes = &#123; store: React.PropTypes.object,&#125;; 自顶向下地看以下如何使用到TodoApp中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 1. 使用 Provider 包裹 TodoApp，并将 store 作为 props 传入ReactDOM.render( &lt;Provider store=&#123;createStore(rootReducer, initialState)&#125;&gt; &lt;TodoApp /&gt; &lt;/Provider&gt;, document.getElementById('container'),);// 2. 根组件 TodoApp: 和 store say goodbye~，// 因为 TodoApp 并不是容器组件~const TodoApp = () =&gt; ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList /&gt; &lt;Footer /&gt; &lt;/div&gt;);// 3. AddTodo: 由于 props 固定作为第一个传入子组件的参数，// 所以 &#123; store &#125; 要声明在第二位，然鹅需要声明 contextTypes...const AddTodo = (props, &#123; store &#125;) =&gt; &#123; // ...&#125;;// 必须声明AddTodo.contextTypes = &#123; store: React.PropTypes.object,&#125;;// 4. VisibleTodoList: 从 props 改成从 context 中获取 store，// 同样声明 contextTypes...class VisibleTodoList extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.context; // props -&gt; context // ... &#125; // ... render() &#123; const &#123; store &#125; = this.context; // props -&gt; context const &#123; todos, filter &#125; = store.getState(); // ... &#125;&#125; // 必须声明VisibleTodoList.contextTypes = &#123; store: React.PropTypes.object,&#125;;// -- TodoList 和 Todo 不变 --// 5. Footer：和 store say goodbye...const Footer = () =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink renderFilter=\"SHOW_ALL\"&gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink renderFilter=\"SHOW_COMPLETED\"&gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink renderFilter=\"SHOW_ACTIVE\"&gt; active &lt;/FilterLink&gt; &lt;/p&gt;);// 6. FilterLink: 同 VisibleTodoList（props + contextTypes...）class FilterLink extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.context; // props -&gt; context // ... &#125; // ... render() &#123; const &#123; renderFilter, children &#125; = this.props; const &#123; store &#125; = this.context; // props -&gt; context const &#123; filter &#125; = store.getState(); // ... &#125;&#125; // 必须声明FilterLink.contextTypes = &#123; store: React.PropTypes.object,&#125;;// -- Link 不变 -- 现在中间的非容器组件完全不用为了自己的孩子而费劲地传递 store={store}所以以上我们就实现了简化版的由 react-redux 提供的第一个组件 &lt;Provider /&gt;。 然鹅，有木有觉得老写 contextTypes 好烦啊，而且 context 特性并不稳定，所以 context 并不应该直接写在我们的应用代码里。 计将安出？ (5). connect-OOP思维：这还不简单？写个函数把容器组件传进去作为父类，然后返回写好了 componentDidMount，componentWillUnmount 和 contextTypes 的子类不就好啦~ 恭喜你~面向对象的思想学的很不错~ 虽然 JavaScript 底层各种东西都是面向对象，然而在前端一旦与界面相关，照搬面向对象的方法实现起来会很麻烦… React 早期用户：这还不简单？写个 mixin 岂不美哉~~？作为 react 亲生的 mixin 确实在多组件间共享方法提供了一些便利，然而使用 mixin 的组件需要了解细节，从而避免状态污染，所以一旦 mixin 数量多了之后会越来越难维护。 Unfortunately, we will not launch any mixin support for ES6 classes in React. That would defeat the purpose of only using idiomatic JavaScript concepts. 所以官方也放弃了在 ES6 class 中对 mixin 的支持。 函数式（FP）：高阶组件 High Order Component（下称 hoc）才是终极解决方案~~ hocFactory:: W: React.Component =&gt; E: React.Component 如上所示 hoc 的构造函数接收一个 W（代表 WrappedComponent）返回一个 E（代表 Enhanced Component），而 E 就是这个高阶组件。 假设我们有一个旧组件 Comp，然鹅现在接收参数有些变动。 当然你可以复制粘贴再修改旧组件的代码…（大侠受窝一拜） 也可以这么写，返回一个新组件来包裹旧组件。 12345678class NewComp extends Component &#123; mapProps(props) &#123; return &#123;/* new props */&#125;; &#125; render() &#123; return (&lt;Comp &#123;...this.mapProps(this.props)&#125; /&gt;); &#125;&#125; 然鹅，如果有同样逻辑的更多的组件需要适配呢？？？总不能有几个抄几遍吧… 所以骚年你听说过高阶组件么~？ 123456789// 先返回一个函数，而那个函数再返回新组件const mapProps = mapFn =&gt; Comp =&gt; &#123; return class extends Component &#123; render() &#123; return (&lt;Comp &#123;...this.mapFn(this.props)&#125; /&gt;); &#125; &#125;;&#125;;const NewComp = mapProps(mapFn)(Comp); // 注意调用了两次 可以看到借助高阶组件我们将 mapFn 和 Comp 解耦合，这样就算需要再嵌套多少修改逻辑都没问题天黑都不怕 ok,扯了这么多得淡，终于要说到connect了 是哒，你木有猜错，react-redux 提供的第二个也是最后一个 api —— connect 返回的就是一个高阶组件。 使用的时候只需要 connect()(WrappedComponent) 返回的 component 自动就完成了在 componentDidMount 中订阅 store，在 componentWillUnmount 中取消订阅和声明 contextTypes。 这样就只剩下最后一个麻烦 应用其实并不需要渲染所有的 todos，所以内部很麻烦地定义了 _getVisibleTodos 函数 其实 connect 函数的第一个参数叫做 mapStateToProps，作用就是将 store 中的数据提前处理或过滤后作为 props 传入内部组件，以便内部组件高效地直接调用。这样最后一个麻烦也解决了~ 然鹅，我们问自己这样就够了么？并没有… 还有最后一个细节，以 FilterLink 为例。 1234567891011121314151617class FilterLink extends Component &#123; // ... render() &#123; const &#123; store, renderFilter, children &#125; = this.props; const &#123; filter &#125; = store.getState(); return ( &lt;Link active=&#123;filter === renderFilter&#125; onClick=&#123;() =&gt; store.dispatch( setVisibilityFilter(renderFilter) )&#125; &gt; &#123;children&#125; &lt;/Link&gt; ); &#125;&#125; 除了从 store 中获取数据（filter），我们还从中获取了 dispatch，以便触发 action。如果将回调函数 onClick 的内容也加到 props 中，那么借助 connect 整个 FilterLink 的逻辑岂不是都被我们抽象完了？ 是哒，connect 的第二个参数叫做 mapDispatchToProps，作用就是将各个调用到 dispatch 的地方都抽象成函数加到 props 中的传给内部组件。这样最后一个麻烦终于真的被解决了~ 1234567891011121314151617const mapStateToLinkProps = (state, ownProps) =&gt; (&#123; // ownProps 是原组件的 props， // 这里为了和高阶组件的 props 区分 active: ownProps.renderFilter === state.filter,&#125;);const mapDispatchToLinkProps = (dispatch, ownProps) =&gt; (&#123; onClick() &#123; dispatch( setVisibilityFilter(ownProps.renderFilter) ); &#125;,&#125;);// 注意原 FilterLink 整个都被我们删了const FilterLink = connect( mapStateToLinkProps, mapDispatchToLinkProps)(Link); TodoApp 使用react-redux 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229// 引入 createStore 方法const &#123; createStore, combineReducers &#125; = Redux;const &#123; Provider, connect &#125; = ReactRedux;// 暂且使用数字作为 idlet nextTodoId = 0;/*-- action creators --*/const addTodo = (text) =&gt; ( &#123; type: 'ADD_TODO', id: nextTodoId++, text &#125;);const toggleTodo = (id) =&gt; ( &#123; type: 'TOGGLE_TODO', id &#125;);const setVisibilityFilter = (filter) =&gt; ( &#123; type: 'SET_VISIBILITY_FILTER', filter &#125;);/*-- reducers --*/// 默认初始状态const initialState = &#123; filter: 'SHOW_ALL', todos: [] &#125;;// 处理单个 todoconst todo = (state, action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return &#123; id: action.id, text: action.text, completed: false, &#125;; case 'TOGGLE_TODO': if (state.id !== action.id) return state; return &#123; ...state, completed: !state.completed, &#125;; default: return state; &#125;&#125;;// 处理 todosconst todos = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, todo(undefined, action), ]; case 'TOGGLE_TODO': return state.map(t =&gt; todo(t, action)); default: return state; &#125;&#125;;// 处理 filterconst filter = (state = 'SHOW_ALL', action) =&gt; &#123; switch (action.type) &#123; case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; &#125;&#125;;const rootReducer = combineReducers(&#123; todos, filter &#125;);/*-- view --*/// dispatch 作为 props 被传入let AddTodo = (&#123; dispatch &#125;) =&gt; &#123; let input; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; if (!input.value) return; dispatch(addTodo(input.value)); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &lt;/div&gt; );&#125;;AddTodo = connect()(AddTodo); // 注入 dispatchconst Todo = (&#123; text, onClick, completed &#125;) =&gt; ( &lt;li onClick=&#123;onClick&#125; style=&#123;&#123; textDecoration: completed ? 'line-through' : 'none', cursor: completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;text&#125; &lt;/li&gt;);const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; )&#125; &lt;/ul&gt;);// 根据当前 filter 过滤需要渲染的 todosconst getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed); case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed); default: return todos; &#125;&#125;;const mapStateToTodoListProps = (state) =&gt; (&#123; todos: getVisibleTodos( state.todos, state.filter ),&#125;);const mapDispatchToTodoListProps = (dispatch) =&gt; (&#123; onTodoClick(id) &#123; dispatch(toggleTodo(id)) &#125;,&#125;);const VisibleTodoList = connect( mapStateToTodoListProps, mapDispatchToTodoListProps,)(TodoList);// 原本的 FilterLink 改成 Link，去掉 filter 和 renderFilter 属性，改为传入 activeconst Link = (&#123; active, onClick, children &#125;) =&gt; &#123; if (active) return (&lt;span&gt;&#123;children&#125;&lt;/span&gt;); return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); onClick(); &#125;&#125;&gt; &#123;children&#125; &lt;/a&gt; );&#125;;const mapStateToLinkProps = (state, ownProps) =&gt; (&#123; // ownProps 是原组件的 props， // 这里为了和高阶组件的 props 区分 active: ownProps.renderFilter === state.filter,&#125;);const mapDispatchToLinkProps = (dispatch, ownProps) =&gt; (&#123; onClick() &#123; dispatch( setVisibilityFilter(ownProps.renderFilter) ); &#125;,&#125;);// 注意原 FilterLink 整个都被我们删了const FilterLink = connect( mapStateToLinkProps, mapDispatchToLinkProps)(Link);const Footer = () =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink renderFilter=\"SHOW_ALL\"&gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink renderFilter=\"SHOW_COMPLETED\"&gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink renderFilter=\"SHOW_ACTIVE\"&gt; active &lt;/FilterLink&gt; &lt;/p&gt;);// 清清爽爽~再也不用费劲儿地传入 store 了~const TodoApp = () =&gt; ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList /&gt; &lt;Footer /&gt; &lt;/div&gt;);/*-- ReactDOM 渲染部分 --*/ReactDOM.render( &lt;Provider store=&#123;createStore(rootReducer, initialState)&#125;&gt; &lt;TodoApp /&gt; &lt;/Provider&gt;, document.getElementById('container'),); 四、总结本文从 Redux 的理论基础和源码出发，介绍了 Redux 的各项基础 api。 接着一步一步地介绍如何与 React 进行结合，从过程中的各个痛点引出 react-redux 的作用和原理。 然鹅，还有好多的坑没填，比如：大型项目的文件结构、前端路由（react-router）、中间件（middlewares）、网络请求等各类异步操作、服务器端同构直出… 以上 to be continued… 参考引用博客https://buptsteve.github.io/blog/2016/10/25/7.react-and-redux-learning-note-basics/","categories":[{"name":"前端","slug":"前端","permalink":"https://wudi2010.github.io/blog/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wudi2010.github.io/blog/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"https://wudi2010.github.io/blog/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://wudi2010.github.io/blog/tags/Redux/"}]},{"title":"博客第一篇","slug":"0-blog-first","date":"2016-12-02T06:30:17.000Z","updated":"2016-12-05T07:18:28.000Z","comments":true,"path":"2016/12/02/0-blog-first/","link":"","permalink":"https://wudi2010.github.io/blog/blog/2016/12/02/0-blog-first/","excerpt":"","text":"做为一个IT搞技术的，时刻不能放下学习，写文档笔记可以帮助我梳理学习的内容知识，巩固学习内容。在工作中还可以服务于他人，可为一举多得。原来写文档笔记载体是有道云笔记、WORD文档+网盘自己管理弄得技术笔记很茅草，不能很好的梳理技术知识，这是我建立这个技术博客的初衷。目标帮助自己和我的团队更好的完成日后的工作任务。 博客的建立其实博客的建立非常的偶然，做了好多年技术开发，时长看到别人编写技术博客。有时想自己写写，因为懒，嘿嘿都错过了。平时梳理技术的时候，也记些笔记，不过觉得做的还是不够精细，基本上复制粘贴的多，很多坑就自己知道。实际给别人看的时候，有时候也在坑别人。觉得还是写的态度有点不到位。偶然间看到一个前端开发者的博客，笔记内容写的比较新颖，于是决定使用他使用的技术，编写博客，把技术笔记放上去服务自己服务他人。选择的技术是nodejs为基础环境的hexo3。 主要是这几个优点吧(以下内容引用复制多一些，不过自己以完全实践过，多见谅）: 主要是这几个优点吧： 免费╮(╯▽╰)╭ 基于 Node.js 速度快、操作更简单、命令少，专注于写作本身 由于 deploy 命令，发布到 github 上生成静态站点也很简单所以整个 Blog 就是采用 hexo3 + github pages,主题基于 indigo 进行修改，下面就详细说说怎么搭起来吧.hexo在MAC下的安装Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo的安装是个很快速简便的过程，但依然还是有不少坑。这里记录个我的安装过程，给大家一些参考。以下是我安装时系统及软件版本，请尽量保证不低于这些版本号： OS ： OS X EI Capitan 10.11.3 XCode : 7.3 hexo : 3.2.2 node : 4.4.7 Git : 2.6.4 安装前提需要安装 Node.js 和 Git 两个应用程序，直接到官网安装最新版本即可，如已安装请跳过。 Node.js 官网 Git 官网 安装Hexo安装完Node.js 及 Git 后，即可使用npm来安装Hexo 1$ npm i(nstall) -g hexo npm 安装方式中 -g 的意思是全局安装。 初始化Hexo创建一个目录用来作为你的blog目录，例如 MyBlog；并在该目录中进行Hexo的初始化： 123$ hexo init MyBlog$ cd ~/MyBlog/$ npm install 新建完成后得到以下目录：12345678·|-- _config.yml|-- package.json|-- scaffolds|-- source| |-- _drafts| |-- _posts|-- themes 至此，你就完成了Hexo的安装及初始化，接下来我们就可以进行本地的预览啦：先安装hexo server 1$ npm i(nstall) --save hexo-server npm 安装方式中 –save 的意思是作为项目依赖(dependencies)进行安装，可以缩写为 -S (注意大写)此外还有 –save-dev 的意思是作为项目的「开发」依赖(devDependencies)进行安装，可以缩写为 -D (注意大写)这两种安装方式都会将这个包的名称和版本写进 package.json 配置文件中 然后生成静态页面并打开hexo本地服务 12$ hexo g(enerate) (或 hexo g)$ hexo s(erver) (或 hexo s) 按命令行提示，打开 http://localhost:4000/ 即可看到默认主题的默认页面了。可能加载会很慢，因为默认主题中使用了些Google的资源，后面更换主题就会快很多了。 配置与Github账户关联首先需要去Github注册一个账号，并新建一个名为 [your_account].github.io 的仓库。 个人在此位置的时候遇到了好多问题，解决了好久。github原来没有用过，github.io域名的仓库怎么建立？怎么部署到github上？学习好久，这其中有两个坑，下面把他先填上。 关于 github pages 项目站点（Project Pages）github 会根据 gh-pages 分支下文件生成静态页面，地址是 [yourName].github.io/[projectName]。（[yourName] 是你的账户名，[projectName] 是你的项目名） 个人或公司站点（User/Organization Pages）首先要创建一个叫做 [yourName].github.io 的项目，接着 github 会根据 master 分支下文件生成静态页面，地址是 [yourName].github.io/。 生成 github pages 此处坑已填 首先在github上建立一个项目，如果是项目站点用[projectName],个人站点用[yourname]。 进入你所建立的项目中，点击项目配置[settings]选项，配置改项目 下拉设置页面，找到GitHub Pages区域，点击[Lauch automatic page generator]按钮，就会按照你的定义生成一个项目介绍的模板，同样这时github pages，你要配置的项目站点或个人站点将已经启动。 部署上传Blog通过Hexo的部署命令，直接可以将编写好的blog上传到网络空间，对外发布。部署上传配置如下：打开前面创建的MyBlog目录下的 _config.yml 文件，在修改最下方的deploy为：*注意，冒号后面一定要加空格官方文档中是这么介绍的 1234567891011121314151617# You can use this:deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message]# or this:deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] #repo: Repository URL#branch: Git branch to deploy the static site to#message: Commit message. The default commit message is Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;. 接下来安装hexo的git部署，在命令行中执行：1$ npm install hexo-deployer-git --save 最后，将生成静态页面并部署到github的仓库中，执行：1234$ hexo d -g 或者$ hexo generate$ hexo deploy 当提示 INFO Deploy done: git 即上传成功，这时就可以通过 http:\\/\\/[your_account].github.io 来访问你的个人站点,如果是项目站点增加[projectName]。 此处有坑，刚注册完成github的，如果不配置sshkeys或者是gpgkey是部署不到gitpages中。所以ssh应该生成ssh的公司密钥对，gpg应该生成gpg公司密钥对，本人gpg是参见官方文档完成。具体内容如下： Download and install the GPG command line tools 下载GPG命令行工具 打开系统命令行执行。Open Terminal。 生成 GPG key。1gpg --gen-key hexo的基本配置以下是hexo配置文件 _config.yml 的基本内容及基本设置，更多个性化设置请参考官方文档： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site ##页面信息title: Who&apos;s Blog ##标题，即浏览器标签栏显示的内容subtitle: Why so serious? ##副标题description: ##描述，简介author: wu di ##作者language: zh-CN ##语言timezone: Asia/Shanghai ##时区# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://wwww.charleswei.me ##域名，后面自定义域名后，写在这里，用 .github.io的话，这里用默认的不用改root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory ##文件目录，可不改source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing ##静态页面生成属性，可不改new_post_name: :year-:month-:day-:title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag ##标签，可不改default_category: uncategorizedcategory_map:tag_map:# Date / Time format ##时间格式，可不改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ##每页显示文章数，按需改## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions ##主题设置## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: indigo# Deployment ##git部署关联## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/wudi2010/blog.git,gh_pages branch: master 主题配置Hexo具有高定制的主题效果，你可以从Hexo的主题库中选择合适的主题，也可以自己制作。以我现在使用的indigo主题为例。首先将主题库clone到MyBlog目录下的themes目录： 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 安装less，主题使用less作为css预处理工具： 1npm install hexo-renderer-less --save 安装feed,用于生吃RSS： 1npm install hexo-generator-feed --save 安装json-content，用于生成静态站点数据，提供搜索功能的数据源： 1npm install hexo-generator-json-content --save 开启标签页： 1hexo new page tags 修改MyBlog/source/tags/index.md的源数据： 此处有坑，网上各地方的答案根本不好使，请严格按照下方编写。1234layout: tagsnoDate: truecomments: false--- 修改hexo配置文件_config.yml中的主题标签： 1theme: indigo 最后修改主题配置文件MyBlog/themes/indigo/_config.yml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# hexo-theme-indigo# https://github.com/yscoder/hexo-theme-indigo#添加新菜单项遵循以下规则# menu:# link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须# text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写# url: /about 链接，绝对或相对路径，必须。# target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: text: 归档 url: /archives tags: text: 标签 url: /tags th: text: 分类 url: /categories github: url: https://github.com/wudi2010 target: _blank about: text: 关于 url: /aboutrss: /atom.xml#你的头像urlavatar: /img/avatar.jpg#faviconfavicon: /img/favicon.ico# emailemail: 28679382@qq.com# 设置 Android L Chrome 浏览器状态栏颜色color: &apos;#3F51B5&apos;# 页面标题tags_title: 标签archives_title: 归档categories_title: 分类# 文章截断excerpt_render: falseexcerpt_length: 300excerpt_link: 阅读全文...mathjax: falsearchive_yearly: true#是否开启分享share: true#是否开启打赏，关闭 reward: falsereward: falsetitle: 谢谢大爷~wechat: /img/wechat.jpg #微信，关闭设为 falsealipay: /img/alipay.jpg #支付宝，关闭设为 false#是否开启搜索search: true#是否大屏幕下文章页隐藏导航hideMenu: false#是否开启toc#toc: falsetoc: list_number: true # 是否显示数字排序#文章页版权声明内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.iocopyright: 本文地址：&lt;a href=&quot;&lt;%- url_for(page.path).replace(/index\\.html$/, &apos;&apos;) %&gt;&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;%- url.replace(/index\\.html$/, &apos;&apos;) %&gt;&lt;/a&gt;#站长统计，如要开启，输入CNZZ站点id，如 cnzz: 1255152447cnzz: false# Miscellaneousgoogle_analytics: falsegoogle_site_verification: false# lessless: compress: true paths: - source/css/style.less# 是否开启多说评论，填写你在多说创建的站点二级域名duoshuo: ysblog# 使用 disqus 时关闭多说评论#disqus_shortname: false# 规范网址# 让搜索引擎重定向你的不同域名、不同子域、同域不同目录的站点到你期望的路径# https://support.google.com/webmasters/answer/139066# 假设配置为 canonical: http://imys.net，那么从搜索引擎中 www.imys.net 进入会重定向到 imys.netcanonical: false# 版权起始年份since_year: 2016# 用户页面中作者相关的描述性文字，如不需要设为 falseabout: false 最后生成部署，来看看效果吧12hexo cleanhexo d -g","categories":[],"tags":[{"name":"hexo3","slug":"hexo3","permalink":"https://wudi2010.github.io/blog/tags/hexo3/"}]},{"title":"最新开始的博客","slug":"My-New-Post","date":"2016-12-02T06:30:17.000Z","updated":"2016-12-03T06:27:45.000Z","comments":true,"path":"2016/12/02/My-New-Post/","link":"","permalink":"https://wudi2010.github.io/blog/blog/2016/12/02/My-New-Post/","excerpt":"","text":"使用说明重点说明模块Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 代码模块1[rectangle setX: 10 y: 10 width: 20 height: 20]; Array.map1array.map(callback[, thisArg]) content webstorm 11代码自动换行开始写的时候才发现代码根本不会自己换行,去网上找教程依然找不到其他网友说的IDE settings,应该也是由于是版本不同的问题,后来在preferences-editor-general中找到了Use soft wraps in editor选项,勾选上即可自动换行.","categories":[{"name":"技术总结","slug":"技术总结","permalink":"https://wudi2010.github.io/blog/categories/技术总结/"}],"tags":[{"name":"Injury","slug":"Injury","permalink":"https://wudi2010.github.io/blog/tags/Injury/"},{"name":"Fight","slug":"Fight","permalink":"https://wudi2010.github.io/blog/tags/Fight/"},{"name":"Shocking","slug":"Shocking","permalink":"https://wudi2010.github.io/blog/tags/Shocking/"}]}]}